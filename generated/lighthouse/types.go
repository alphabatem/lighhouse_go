// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package lighthouse

import (
	"encoding/binary"
	"errors"
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type TestAccountV1 struct {
	U8            uint8
	I8            int8
	U16           uint16
	I16           int16
	U32           uint32
	I32           int32
	U64           uint64
	I64           int64
	U128          ag_binary.Uint128
	I128          ag_binary.Int128
	Bytes         [32]uint8
	TrueField     bool
	FalseField    bool
	OptionU8      *uint8  `bin:"optional"`
	OptionU8None  *uint8  `bin:"optional"`
	OptionU16     *uint16 `bin:"optional"`
	OptionU16None *uint16 `bin:"optional"`
	Pubkey        ag_solanago.PublicKey
	Vec           []byte
}

func (obj TestAccountV1) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `U8` param:
	err = encoder.Encode(obj.U8)
	if err != nil {
		return err
	}
	// Serialize `I8` param:
	err = encoder.Encode(obj.I8)
	if err != nil {
		return err
	}
	// Serialize `U16` param:
	err = encoder.Encode(obj.U16)
	if err != nil {
		return err
	}
	// Serialize `I16` param:
	err = encoder.Encode(obj.I16)
	if err != nil {
		return err
	}
	// Serialize `U32` param:
	err = encoder.Encode(obj.U32)
	if err != nil {
		return err
	}
	// Serialize `I32` param:
	err = encoder.Encode(obj.I32)
	if err != nil {
		return err
	}
	// Serialize `U64` param:
	err = encoder.Encode(obj.U64)
	if err != nil {
		return err
	}
	// Serialize `I64` param:
	err = encoder.Encode(obj.I64)
	if err != nil {
		return err
	}
	// Serialize `U128` param:
	err = encoder.Encode(obj.U128)
	if err != nil {
		return err
	}
	// Serialize `I128` param:
	err = encoder.Encode(obj.I128)
	if err != nil {
		return err
	}
	// Serialize `Bytes` param:
	err = encoder.Encode(obj.Bytes)
	if err != nil {
		return err
	}
	// Serialize `TrueField` param:
	err = encoder.Encode(obj.TrueField)
	if err != nil {
		return err
	}
	// Serialize `FalseField` param:
	err = encoder.Encode(obj.FalseField)
	if err != nil {
		return err
	}
	// Serialize `OptionU8` param (optional):
	{
		if obj.OptionU8 == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.OptionU8)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `OptionU8None` param (optional):
	{
		if obj.OptionU8None == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.OptionU8None)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `OptionU16` param (optional):
	{
		if obj.OptionU16 == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.OptionU16)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `OptionU16None` param (optional):
	{
		if obj.OptionU16None == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.OptionU16None)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Pubkey` param:
	err = encoder.Encode(obj.Pubkey)
	if err != nil {
		return err
	}
	// Serialize `Vec` param:
	err = encoder.Encode(obj.Vec)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TestAccountV1) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `U8`:
	err = decoder.Decode(&obj.U8)
	if err != nil {
		return err
	}
	// Deserialize `I8`:
	err = decoder.Decode(&obj.I8)
	if err != nil {
		return err
	}
	// Deserialize `U16`:
	err = decoder.Decode(&obj.U16)
	if err != nil {
		return err
	}
	// Deserialize `I16`:
	err = decoder.Decode(&obj.I16)
	if err != nil {
		return err
	}
	// Deserialize `U32`:
	err = decoder.Decode(&obj.U32)
	if err != nil {
		return err
	}
	// Deserialize `I32`:
	err = decoder.Decode(&obj.I32)
	if err != nil {
		return err
	}
	// Deserialize `U64`:
	err = decoder.Decode(&obj.U64)
	if err != nil {
		return err
	}
	// Deserialize `I64`:
	err = decoder.Decode(&obj.I64)
	if err != nil {
		return err
	}
	// Deserialize `U128`:
	err = decoder.Decode(&obj.U128)
	if err != nil {
		return err
	}
	// Deserialize `I128`:
	err = decoder.Decode(&obj.I128)
	if err != nil {
		return err
	}
	// Deserialize `Bytes`:
	err = decoder.Decode(&obj.Bytes)
	if err != nil {
		return err
	}
	// Deserialize `TrueField`:
	err = decoder.Decode(&obj.TrueField)
	if err != nil {
		return err
	}
	// Deserialize `FalseField`:
	err = decoder.Decode(&obj.FalseField)
	if err != nil {
		return err
	}
	// Deserialize `OptionU8` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.OptionU8)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `OptionU8None` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.OptionU8None)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `OptionU16` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.OptionU16)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `OptionU16None` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.OptionU16None)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Pubkey`:
	err = decoder.Decode(&obj.Pubkey)
	if err != nil {
		return err
	}
	// Deserialize `Vec`:
	err = decoder.Decode(&obj.Vec)
	if err != nil {
		return err
	}
	return nil
}

type AccountDataAssertion struct {
	Offset    CompactU64
	Assertion DataValueAssertion
}

func (obj AccountDataAssertion) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Offset` param:
	err = encoder.Encode(obj.Offset)
	if err != nil {
		return err
	}
	// Serialize `Assertion` param:
	err = encoder.Encode(obj.Assertion)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AccountDataAssertion) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Offset`:
	err = decoder.Decode(&obj.Offset)
	if err != nil {
		return err
	}
	// Deserialize `Assertion`:
	err = decoder.Decode(&obj.Assertion)
	if err != nil {
		return err
	}
	return nil
}

type DataValueAssertion []byte

type AccountDataAssertions []AccountDataAssertion

type TokenAccountAssertions []*TokenAccountAssertion

// Placeholders for assertions
type TokenAccountAssertion struct {
	Mint            *ag_solanago.PublicKey
	Owner           *ag_solanago.PublicKey
	Amount          *uint64
	Delegate        *ag_solanago.PublicKey
	State           *[]byte
	IsNative        *bool
	DelegatedAmount *uint64
	CloseAuthority  *ag_solanago.PublicKey

	Operator uint8
}

func (t *TokenAccountAssertion) Type() uint8 {
	if t.Mint != nil {
		return 0
	}
	if t.Owner != nil {
		return 1
	}
	if t.Amount != nil {
		return 2
	}
	if t.Delegate != nil {
		return 3
	}
	if t.State != nil {
		return 4
	}
	if t.IsNative != nil {
		return 5
	}
	if t.DelegatedAmount != nil {
		return 6
	}
	if t.CloseAuthority != nil {
		return 7
	}
	return 99
}

func (t *TokenAccountAssertion) TypeString() string {
	if t.Mint != nil {
		return "Mint"
	}
	if t.Owner != nil {
		return "Owner"
	}
	if t.Amount != nil {
		return "Amount"
	}
	if t.Delegate != nil {
		return "Delegate"
	}
	if t.State != nil {
		return "State"
	}
	if t.IsNative != nil {
		return "IsNative"
	}
	if t.DelegatedAmount != nil {
		return "DelegatedAmount"
	}
	if t.CloseAuthority != nil {
		return "CloseAuthority"
	}
	return "Unknown"
}

func (t TokenAccountAssertion) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	err = encoder.WriteUint8(t.Type())
	if err != nil {
		return err
	}

	if t.Mint != nil {
		_, err = encoder.Write(t.Mint.Bytes())
		if err != nil {
			return err
		}
	}

	if t.Owner != nil {
		_, err = encoder.Write(t.Owner.Bytes())
		if err != nil {
			return err
		}
	}
	if t.Amount != nil {
		err = encoder.WriteUint64(*t.Amount, binary.LittleEndian)
		if err != nil {
			return err
		}
	}
	if t.Delegate != nil {
		_, err = encoder.Write(t.Delegate.Bytes())
		if err != nil {
			return err
		}
	}
	if t.State != nil {
		_, err = encoder.Write(*t.State)
		if err != nil {
			return err
		}
	}
	if t.IsNative != nil {
		err = encoder.WriteBool(*t.IsNative)
		if err != nil {
			return err
		}
	}
	if t.DelegatedAmount != nil {
		err = encoder.WriteUint64(*t.DelegatedAmount, binary.LittleEndian)
		if err != nil {
			return err
		}
	}
	if t.CloseAuthority != nil {
		_, err = encoder.Write(t.CloseAuthority.Bytes())
		if err != nil {
			return err
		}
	}

	err = encoder.WriteUint8(t.Operator)
	if err != nil {
		return err
	}

	return nil
}

func (t TokenAccountAssertion) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	byt, err := decoder.ReadUint8()
	if err != nil {
		return err
	}

	switch byt {
	case 0: //Mint
		if err := decoder.Decode(&t.Mint); err != nil {
			return err
		}
	case 1: //Owner
		if err := decoder.Decode(&t.Owner); err != nil {
			return err
		}
	case 2: //Amount
		if err := decoder.Decode(&t.Amount); err != nil {
			return err
		}
	case 3: //Delegate
		opk, err := decoder.ReadByte()
		if err != nil {
			return err
		}

		if opk == 1 {
			if err := decoder.Decode(&t.Delegate); err != nil {
				return err
			}
		} else {
			t.Delegate = &ag_solanago.PublicKey{}
		}
	case 4: //State
		if err := decoder.Decode(&t.State); err != nil {
			return err
		}
	case 5: //IsNative
		if err := decoder.Decode(&t.IsNative); err != nil {
			return err
		}
	case 6: //DelegatedAmount
		if err := decoder.Decode(&t.DelegatedAmount); err != nil {
			return err
		}
	case 7: //CloseAuthority
		if err := decoder.Decode(&t.CloseAuthority); err != nil {
			return err
		}
	default:
		return errors.New(fmt.Sprintf("unknown assertation type (%v)", byt))
	}

	return decoder.Decode(&t.Operator)
}

type AccountInfoAssertions []*AccountInfoAssertion

// Placeholders for assertions
type AccountInfoAssertion struct {
	Lamports   *uint64
	DataLength *uint64
	Owner      *ag_solanago.PublicKey
	RentEpoch  *uint64
	IsSigner   *bool
	IsWritable *bool
	Executable *bool

	Operator uint8
}

func (t *AccountInfoAssertion) Type() uint8 {
	if t.Lamports != nil {
		return 0
	}
	if t.DataLength != nil {
		return 1
	}
	if t.Owner != nil {
		return 2
	}
	//Known Owner = 3
	if t.RentEpoch != nil {
		return 4
	}
	if t.IsSigner != nil {
		return 5
	}
	if t.IsWritable != nil {
		return 6
	}
	if t.Executable != nil {
		return 7
	}
	//VerifyDatahash = 8

	return 99
}

func (t AccountInfoAssertion) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	err = encoder.WriteUint8(t.Type())
	if err != nil {
		return err
	}

	if t.Lamports != nil {
		err = encoder.WriteUint64(*t.Lamports, binary.LittleEndian)
		if err != nil {
			return err
		}
	}
	if t.DataLength != nil {
		err = encoder.WriteUint64(*t.DataLength, binary.LittleEndian)
		if err != nil {
			return err
		}
	}
	if t.Owner != nil {
		_, err = encoder.Write(t.Owner.Bytes())
		if err != nil {
			return err
		}
	}
	if t.RentEpoch != nil {
		err = encoder.WriteUint64(*t.RentEpoch, binary.LittleEndian)
		if err != nil {
			return err
		}
	}
	if t.IsSigner != nil {
		err = encoder.WriteBool(*t.IsSigner)
		if err != nil {
			return err
		}
	}
	if t.IsWritable != nil {
		err = encoder.WriteBool(*t.IsWritable)
		if err != nil {
			return err
		}
	}
	if t.Executable != nil {
		err = encoder.WriteBool(*t.Executable)
		if err != nil {
			return err
		}
	}

	err = encoder.WriteUint8(t.Operator)
	if err != nil {
		return err
	}
	return nil
}

func (t AccountInfoAssertion) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	byt, err := decoder.ReadUint8()
	if err != nil {
		return err
	}

	switch byt {

	case 0: //Lamports
		if err := decoder.Decode(t.Lamports); err != nil {
			return err
		}
	case 1: //DataLength
		if err := decoder.Decode(t.DataLength); err != nil {
			return err
		}
	case 2: //Owner
		if err := decoder.Decode(t.Owner); err != nil {
			return err
		}
	case 4: //RentEpoch
		if err := decoder.Decode(t.RentEpoch); err != nil {
			return err
		}
	case 5: //IsSigner
		if err := decoder.Decode(t.IsSigner); err != nil {
			return err
		}
	case 6: //IsWritable
		if err := decoder.Decode(t.IsWritable); err != nil {
			return err
		}
	case 7: //Executable
		if err := decoder.Decode(t.Executable); err != nil {
			return err
		}
	default:
		return errors.New(fmt.Sprintf("unknown assertation type (%v)", byt))
	}

	return decoder.Decode(&t.Operator)
}

type SysvarClockAssertion Assertion
type StakeAccountAssertions Assertion
type AccountDeltaAssertion Assertion
type BubblegumTreeConfigAssertion Assertion
type MerkleTreeAssertion Assertion
type MintAccountAssertion Assertion
type MintAccountAssertions Assertion
type StakeAccountAssertion Assertion
type UpgradeableLoaderStateAssertion Assertion
type UpgradeableLoaderStateAssertions Assertion
type WriteType Assertion

type Assertion struct {
	Typ  uint8
	Data []byte
}
